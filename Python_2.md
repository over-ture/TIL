# Python 기본문법 2일차

## ★list★

**여러 개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형**

**리스트 표현**

- 대괄호 [] 안에 값들을 쉼표(,)로 구분하여 만듦

- 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음

- 값을 추가, 수정, 삭제하는 등 자유롭게 변경할 수 있음

**리스트의 시퀀스 특징**

- 리스트는 시퀀스이므로, 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용 가능
```python
my_list = [1, 'a', 3, 'b', 5]

# 인덱싱
print(my_list[1])  # a

# 슬라이싱
print(my_list[2:4])  # [3, 'b']
print(my_list[:3])  # [1, 'a', 3]
print(my_list[3:])  # ['b', 5]
print(my_list[::2])  # [1, 3, 5]
print(my_list[::-1])  # [5, 'b', 3, 'a', 1]

# 길이
print(len(my_list))  # 5
```

**중첩 리스트(Nested List)**

- 다른 리스트를 값으로 가진 리스트

- 중첩 리스트 접근하기

    - 인덱스를 연달아 사용하여 안쪽 리스트의 값에 접근할 수 있음

    1. 먼저 바깥 리스트의 
    인덱스로 리스트를 선택

        - my_list[4] -> ['hello', 'world', '!!!']

    2. 선택된 안쪽 리스트에 다시 한번 인덱스를 사용
        - my_list[4][-1] -> '!!!'

**리스트의 가변성**

1. 인덱싱으로 값 수정하기

```python
# 1. 인덱싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[1] = 'two'
print(my_list)  # [1, 'two', 3, 4, 5]
```

2. 슬라이싱으로 여러 값 한번에 바꾸기

```python
# 2. 슬라이싱으로 값 수정
my_list = [1, 2, 3, 4, 5]
my_list[2:4] = ['three', 'four']
print(my_list)  # [1, 2, 'three', 'four', 5]
```

## tuple

**여러 개의 값을 순서대로 저장하는 변경 불가능한 시퀀스 자료형**

**튜플 표현**

- 소괄호 () 안에 값들을 쉼표(,)로 구분하여 만듦

- 모든 종류의 데이터를 담을 수 있음

- 리스트와 거의 모든 면에서 비슷하지만, 한번 만들어지면 절대 수정할 수 없다는 결정적인 차이가 있음

- 단일 요소 튜플을 만들 때는 반드시 Trailing comma(후행 쉼표)를 사용해야 함

**튜플의 시퀀스 특징**
```python
my_tuple = (1, 'a', 3, 'b', 5)

# 인덱싱
print(my_tuple[1])  # a

# 슬라이싱
print(my_tuple[2:4])  # (3, 'b')
print(my_tuple[:3])  # (1, 'a', 3)
print(my_tuple[3:])  # ('b', 5)
print(my_tuple[::2])  # (1, 3, 5)
print(my_tuple[::-1])  # (5, 'b', 3, 'a', 1)

# 길이
print(len(my_tuple))  # 5
```
**튜플 변경 시도하기**

- 한번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제할 수 없음
```python
my_tuple = (1, 'a', 3, 'b', 5)

# 튜플은 불변
# TypeError: 'tuple' object does not support item assignment
my_tuple[1] = 'z'
```

**튜플은 어디에 쓰일까? (튜플이 불변 자료형인 이유)**

- 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용됨

- 다중 할당, 값 교환, 함수 다중 반환 값 등

```python
# 다중 할당
x, y = 10, 20
print(x)  # 10
print(y)  # 20
# 실제 내부 동작
# (x, y) = (10, 20)

# 값 교환
x, y = 1, 2
x, y = y, x
# 실제 내부 동작
temp = (y, x)  # 튜플 생성
x, y = temp  # 튜플 언패킹
print(x, y)  # 2 1
```

## range

- 연속된 정수 시퀀스를 생성하는, 변경 불가능한(immutable) 자료형

- 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용

- 실제로 모든 숫자를 메모리에 저장하는 대신, 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리를 매우 효율적으로 사용

**range 기본 구문**

- range()는 1개, 2개, 또는 3개의 __매개변수(인자)__ 를 가질 수 있다.
```python
range(start, stop, step)
```

**range의 규칙**

1. 값의 범위 규칙

    - stop 값은 생성되는 시퀀스에 절대 포함되지 않음

    - `range(1,5)`는 1부터 5 '전' 까지의 숫자를 의미하므로 1, 2, 3, 4가 생성

2. 증가/감소 값(step) 규칙

    - step 값은 숫자 시퀀스의 간격과 방향

    1. step이 양수일 때(기본값: 1)

        - 숫자가 start부터 stop을 향해 증가

        - `range(1, 10, 2)` -> 1, 3, 5, 7, 9

    2. step이 음수일 때

        - 숫자가 start부터 stop을 향해 감소

        - 이 경우, start 값은 stop 값보다 반드시 커야 함

        - `range(10, 1, -2)` -> 10, 8, 6, 4, 2

**range 활용 예시**

- 주로 반복문과 함께 활용 예정

## ★dict★

**key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형**

**딕셔너리 표현**

- 중괄호 {} 안에 값들이 쉼표(,)로 구분되어 있음

- 값 1개는 키와 값이 쌍으로 이루어져 있음

- Key(키)

    - 값을 식별하기 위한 고유한 '이름표' (중복 불가)

- Value(값)

    - 키에 해당하는 실제 데이터

- 각 값에는 순서가 없음

**딕셔너리의 순서?**

- 딕셔너리는 순서는 없지만 파이썬 3.7 이상에서는 입력한 순서는 출력 시 그대로 유지된다

- 하지만 여전히 딕셔너리의 핵심은 순서가 없는 자료형이라는 점과 Key를 통한 접근이라는 점을 기억할 것

**Key의 규칙**

- 고유해야 함
    
    - Key는 중복될 수 없음

- 변경 불가능한(immutable) 자료형만 사용 가능

    - O (가능): `str, int, float, tuple`

    - X (불가능): `list, dict`

**Value의 규칙**

- 어떤 자료형이든 자유롭게 사용할 수 있음

## set

**순서와 중복이 없는 변경 가능한 자료형**

**세트 표현**

- 중괄호 {} 안에 값들을 쉼표(,)로 구분하여 만듦

- 수학에서의 집합과 동일한 연산 처리 가능

**세트의 두 가지 핵심 특징**

1. 중복을 허용하지 않음

    - 똑같은 값은 단 하나만 존재할 수 있음

2. 순서가 없음

    - 인덱싱(`set[0]`)이나 슬라이싱(`set[0:2]`)을 사용할 수 없음

**세트의 집합 연산**

- 세트는 수학의 '집합'개념을 그대로 가져와, 두 데이터 그룹 간의 관계를 파악하는 데 매우 효과적
```python
# 세트의 집합 연산산
my_set_1 = {1, 2, 3}
my_set_2 = {3, 6, 9}

# 합집합
print(my_set_1 | my_set_2)  # {1, 2, 3, 6, 9}

# 차집합
print(my_set_1 - my_set_2)  # {1, 2}

# 교집합
print(my_set_1 & my_set_2)  # {3}
```
## None

**파이썬에서 '값이 없음'을 표현하는 특별한 데이터 타입**

- 마치 내용물이 없는 빈 상자와 같다

- 숫자 0이나 빈 문자열('')과는 다른, '값이 존재하지 않음' 또는 '아직 정해지지 않음'이라는 상태를 나타내기 위해 사용

```python
# None
my_variable = None
print(my_variable)  # None
```

## Boolean

**'참(True)'과 '거짓(False)' 단 두 가지 값만 가지는 데이터 타입**

- 온/오프 스위치처럼, 프로그램의 흐름을 제어하는 조건문에서 '맞다' 또는 '틀리다'를 판단하는 역할

**Boolean 표현**

- 비교 / 논리 연산의 평가 결과로 사용됨

## Collection

**여러 개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말**

| 컬렉션명 | 변경 가능 여부 | 순서 존재 여부 |
| :---: | :---: | :---: |
| str | X | O |
| list | O | O |
| tuple | X | O |
| dict | O | X |
| set | O | X |

**불변 vs 가변**

| 구분 | 불변 (Immutable) | 가변 (Mutable) |
| :---: | :---: | :---: |
| 특징 | 변경 불가, 안전성, 예측 가능 | 변경 가능, 유연성, 효율성 |
| 종류 | str, tuple, range | list, dict, set |

## 형변환

**한 데이터 타입을 다른 데이터 타입으로 변환하는 과정**

**암시적 형변환**

- 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것

**암시적 형변환 예시**

- 정수와 실수의 연산에서 정수가 실수로 변환됨

- Boolean과 Numeric Type에서만 가능

**명시적 형변환**

- 개발자가 변환하고 싶은타입을 직접 함수로 지정하여 변환하는 것

## 연산자

**복합 연산자**

- 연산과 할당이 함께 이뤄짐

| 기호 | 예시 | 의미 |
| :---: | :---: | :---: |
| `+=` | a += b |  a = a + b |
| `-=` | a -= b | a = a - b |
| `*=` | a *= b | a = a * b |
| `/=` | a /= b | a = a / b |
| `//=` | a //= b | a = a // b |
| `%=` | a %= b | a = a % b |
| `**=` | a **= b | a = a ** b |

**비교 연산자**

- 두 값을 비교하여 그 관계가 맞는지 틀린지를 `True` 또는 `False`로 반환

| 기호 | 내용 |
| :---: | :---: |
| < | 미만 |
| <= | 이하 |
| > | 초과 |
| >= | 이상 |
| == | 같음 |
| != | 같지 않음 |
| is | 같음 |
| is not | 같지 않음 |

**== 연산자**

- 값(데이터)이 같은지를 비교

- 동등성 (equality)

- 예를 들어, `1 == True`의 경우 파이썬이 내부적으로 `True`를 `1`로 간주할 수 있으므로 `True` 결과가 나옴

**is 연산자**

- 객체 자체가 같은지를 비교

- 식별성(identity)

- 두 변수가 완전히 동일한 객체를 가리키는지, 즉 메모리 주소가 같은지를 비교

**is 대신 ==를 사용해야 하는 이유**

- **결론**: `is`는 '정체성'을, `==`는 '가치'를 비교하기 때문

- 두 연산자는 "같다"를 확인하는 목적이 근본적으로 다름

**is 연산자는 언제 사용하는가?**

- 주로 싱글턴 객체를 비교할 때 사용함

**싱글턴(Singleton) 객체란?**

- 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 개체

- 여러 변수가 이 값을 가지더라도, 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐

- 파이썬의 대표적인 싱글턴 객체: `None, True, False`