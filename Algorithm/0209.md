# Stack 자료구조 이해

## 스택의 개념

### 후입선출
**LIFO, Last-In-First-Out**
- 가장 마지막에 넣은 자료가 가장 먼저 나오는 것

### 스택의 기본 연산

- 배열을 사용해 구현할 수 있음
  - 파이썬에서는 리스트를 사용
- 저장소 자체를 스택이라 부르기도 함
  - 용도에 따라 메모리의 일부를 스택으로 부른다
- 스택에서 마지막 삽입된 원소의 위치
  - 스택 포인터, top으로 부르며 데이터를 넣거나 뺄 때 기준이 되는 위치

#### 스택의 연산

- 삽입 (Push)
  - 저장소에 자료를 저장하는 연산으로, 보통 push라고 부른다
- 삭제 (Pop)
  - 저장소에서 삽입한 자료의 역순으로 꺼내는 연산으로, 보통 pop이라고 부른다
- 스택이 공백인지 아닌지를 확인하는 연산 (isEmpty)
  - 스택이 비어 있으면 True, 아니면 False를 반환
- 스택의 top에 있는 item(원소)를 반환하는 연산 (peek)
  - 삭제는 하지 않는다.

#### 스택의 삽입/삭제 과정
![alt text](images/stack_process.png)


## Stack 구현 실습

### Push 연산
- append 메소드를 통해 리스트의 마지막에 데이터를 삽입
  ```python
  s = []
  def my_push(item):
    s.append(iten)
  ```
- 인덱스 연산을 활용한 구현
  ```python
  def my_push(item, size):
    global top
    top += 1
    if top == size:
        print('Overflow!')
    else:
        stack[top] = item
  ```
### 단순한 Push 연산
- 크기가 정해진 리스트와 인덱스 연산을 활용
  ```python
  size = 10
  stack = [0] * size
  top = -1

  my_push(10, size) # my_push 함수 활용
  top += 1
  stack[top] = 20
  ```
### Pop 연산
- 남은 데이터 중 가장 늦게 저장된 데이터를 삭제하는 연산
  ```python
  def py_pop():
    if len(s) == 0:
        print('Overflow!')
        return
    else:
        return s.pop() # 리스트 s의 마지막 원소 삭제
  ```
### 인덱스 연산을 이용한 Pop 연산
- 크기가 정해진 리스트와 인덱스 활용
  ```python
  def my_pop():
    global top
    if top == -1:
        print('Underflow')
        return 0
    else:
        top -= 1
        return stack[top+1]

    print(my_pop())
  ```
  ```python
  if top > -1:
    top -= 1
    print(stack[top+1])
  ```

## 스택 구현 시 고려 사항

- **1차원 배열을 사용하여 구현할 경우**
  - 장점: 구현이 용이합니다.
  - 단점: 스택의 크기를 변경하기가 어렵습니다.

- **해결 방법: 저장소를 동적으로 할당하여 스택을 구현하는 방법(동적 연결리스트를 이용하여 구현하는 방법)**
  - 장점: 메모리를 효율적으로 사용합니다.
  - 단점: 구현이 복잡합니다.


# Stack의 응용

## 괄호 검사

### 괄호의 종류
- **대괄호('[', ']'), 중괄호('{', '}'), 소괄호('(', ')')**

### 조건
1. 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.
2. 같은 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.
3. 괄호 사이에는 포함 관계만 존재한다.

### 잘못된 괄호 사용의 예
```
(a(b)
a(b)c)
a{b(c[d]e}f)
```
![alt text](images/stack_parentheses.png)


#### 괄호를 검사하는 알고리즘 개요
1. 문자열에 있는 괄호를 차례대로 검사하면서 왼쪽 괄호를 만나면 스택에 삽입하고,<br>오른쪽 괄호를 만나면 스택에서 top 괄호를 삭제한 후 오른쪽 괄호와 짝이 맞는지를 검사한다.
   
2. 이 때, 스택이 비어 있으면 조건 1 또는 조건 2에 위배되고 괄호의 짝이 맞지 않으면 조건 3에 위배된다.
   
3. 마지막 괄호까지 조사한 후에도 스택에 괄호가 남아 있으면 조건 1에 위배된다.


## Function Call
![alt text](images/functioncall.png)
![alt text](images/systemstack.png)
